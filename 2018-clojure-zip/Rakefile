require 'slippery'

Slippery::RakeTasks.new do
  title "The Art of Tree Shaping with Zippers"
  type :shower
  add_highlighting :tomorrow

  # shower
  js_options theme: :material, ratio: '16x9'
  #js_options theme: :material


  # reveal_js
  # js_options theme: 'sky', # beige default moon night serif simple sky solarized
  #            transition: 'none',
  #            backgroundTransition: 'none',
  #            width: 1500,  #1680,
  #            height: 1000,  #1050
  #            loop: true

  pack_assets

  transform 'head' do |head|
    head
      .add_child(H[:link, rel: 'stylesheet', type: 'text/css', href: 'style.css'],)
      .add_child(H[:link, rel: 'stylesheet', type: 'text/css', href: 'tomorrow.css'],)
      .add_child(H[:link, rel: 'stylesheet', type: 'text/css', href: 'hljs.css'],)
      .add_child(H[:link, rel: 'stylesheet', type: 'text/css', href: 'https://unpkg.com/tachyons@4.9.1/css/tachyons.min.css'])
  end

  transform('body') do |body|
    body.add_child(H[:script, {type: 'text/javascript', src: 'select_tab.js'}])
  end

  # transform('body') do |body|
  #   body
  #     .set_children(body.children.drop(1))
  #     .add_child(H[:div, {id: "overlay"}, "@plexus"])
  # end

  transform 'section[fullscreen-img]' do |section|
    H[:section, section.attributes, section.children + [
        H[:img, src: section.attr('fullscreen-img'), class: 'cover']]]
  end

  def clojure_exec(src)
    socket = TCPSocket.new('localhost', 5555)
    puts src
    socket.puts %[(require '[zipper-demo.viz :as viz]
                           '[clojure.zip :as z]
                           '[clojure.pprint] :reload)]
    socket.gets # read "nil"
    socket.puts(src)
    socket.puts(":repl/quit")
    result = ''
    while l=socket.gets
      result += l
      puts "[clj] #{l}"
    end
    result
  end

  transform '.slide' do |slide|
    code = slide.select('pre').first
    if code && code.attr('viz')
      source = code.text
      digest = Digest::MD5.hexdigest(source)
      type = "svg"
      viz = code.attr('viz')
      tree_filename = `pwd`.strip + "/img/viz_tree_#{digest}.#{type}"
      zip_filename = `pwd`.strip + "/img/viz_zip_#{digest}.#{type}"
      clojure_exec("(-> #{source} viz/tree->dot (viz/spit \"#{tree_filename}\" :#{type}))")
      clojure_exec("(-> #{source} viz/zipper->dot (viz/spit \"#{zip_filename}\" :#{type}))")
      pprint = clojure_exec("(binding [clojure.pprint/*print-miser-width* 35 clojure.pprint/*print-right-margin* 35] (clojure.pprint/pprint #{source}))")
      slide
        .set_children(slide.children.reject { |c| c.respond_to?(:tag?) && c.tag?(:pre)})
        .add_child(H[:div,
                     {class: "columns", style: "grid-template-columns: 50% 50%; grid-column-gap: 30px;"},
                     code,
                     H[:div, {class: "viz-tabs bg-white ba bw1 b--black-10 br2 overflow-hidden"},
                       H[:div, {class: "f5 bb bw1 b--black-10 flex"},
                         H[:a, {id: "tab_#{digest}_result",
                                class: "tab ttu dib link pa3 black #{'selected' if viz == 'result'}",
                                href: "#",
                                onClick: "selectTab(#{digest.inspect}, 'result')"},
                           "Result"],
                         H[:a, {id: "tab_#{digest}_tree",
                                class: "tab ttu dib link pa3 black #{'selected' if viz == 'tree'}",
                                href: "#",
                                onClick: "selectTab(#{digest.inspect}, 'tree')"},
                           "Tree"],
                         H[:a, {id: "tab_#{digest}_zipper",
                                class: "tab ttu dib link pa3 black #{'selected' if viz == 'zipper'}",
                                href: "#",
                                onClick: "selectTab(#{digest.inspect}, 'zipper')"},
                           "Zipper"]],

                       H[:div, {id: "div_#{digest}_result", class: (viz == 'result' ? "" : "dn"), style: "min-height: 350px; padding-top: 0.5em;"},
                         H[:pre, {class: "language-clojure"},
                           H[:code, {style: "font-size: 80%;"}, pprint.lines[1..-2].join]]],

                       H[:div, {id: "div_#{digest}_tree", class: (viz == 'tree' ? "" : "dn"), style: "min-height: 350px;"},
                         H[:img, {class: "db center", src: tree_filename}]],

                       H[:div, {id: "div_#{digest}_zipper", class: (viz == 'zipper' ? "" : "dn"), style: "min-height: 350px;"},
                         H[:img, {class: "db center", src: zip_filename}]]]])
    else
      slide
    end
  end

  # transform '.fragments, .fragments ul' do |section|
  #   section.map_children do |ch|
  #     if ch.text? || ch.tag?(:h2) || ch.tag?(:ul)
  #       ch
  #     else
  #       ch.add_class('fragment')
  #     end
  #   end
  # end

  # transform '.hljs-attribute' do |attr|
  #   if %w[_links _controls _embedded].include?(attr.text.strip)
  #     H[:strong, attr]
  #   else
  #     attr
  #   end
  # end

  # transform 'li' do |li|
  #   H[:li, li.children.first.children]
  # end

  # transform '.slide.repl' do |section|
  #   code=section.select('code').first.text.lines #.text.split(/^(?=\w+=>)/)
  #   code_blocks = []
  #   H[:div,
  #     code.flat_map do |c|
  #       code_blocks += [c]
  #       if code_blocks.length > 6
  #         code_blocks = code_blocks.drop(1)
  #       end
  #       section.replace('pre') do |pre|
  #         code_blocks.map.with_index do |line, idx|
  #           pre.replace('code') do |code|
  #             if idx == (code_blocks.length-1)
  #               H[:code, {class: "highlight"}, line]
  #             else
  #               H[:code, line]
  #             end
  #           end
  #         end
  #       end
  #     end
  #    ]
  # end

  # transform 'pre.linum' do |pre|
  #   H[:pre, pre.text.lines.map{|l| H[:code, {class: "ruby"}, l]}]
  # end

end

task :default => 'slippery:build:index'
task :watch   => 'slippery:watch:index'
